DÃ©finition

La dette technique correspond Ã  des choix techniques rapides ou non optimaux faits pour livrer plus vite une fonctionnalitÃ©, mais qui gÃ©nÃ¨rent des coÃ»ts futurs (en maintenance, en complexitÃ©, en performance).
Câ€™est comme un emprunt : on gagne du temps au dÃ©part, mais on doit "rembourser" plus tard avec des intÃ©rÃªts (bugs, lenteurs, rigiditÃ©, surcoÃ»t de migration, etc.).

ğŸ“Š Manifestations dans un projet Data

Voici comment la dette technique peut apparaÃ®tre concrÃ¨tement dans ton contexte :

1. Orchestration (Control-M)

Exemple de dette : multiplications de jobs crÃ©Ã©s "vite fait" avec des dÃ©pendances complexes, sans documentation claire.
ğŸ‘‰ RÃ©sultat : lâ€™ordonnancement devient fragile, une simple modification de dÃ©pendance casse toute une chaÃ®ne de traitements.

IntÃ©rÃªts Ã  payer : beaucoup de temps perdu pour analyser les flux lors dâ€™incidents ou migrations.

2. Scripts BTEQ / Teradata

Exemple de dette : des scripts SQL BTEQ trÃ¨s longs, copiÃ©s-collÃ©s dâ€™autres scripts, sans factorisation.
ğŸ‘‰ RÃ©sultat : incohÃ©rences entre environnements, difficultÃ© Ã  maintenir, performance dÃ©gradÃ©e (requÃªtes pas optimisÃ©es, pas dâ€™index adaptÃ©s).

IntÃ©rÃªts Ã  payer : lenteurs croissantes avec la volumÃ©trie, effort supplÃ©mentaire lors de la migration vers Snowflake ou un autre DWH.

3. ETL DataStage

Exemple de dette : jobs DataStage conÃ§us rapidement, avec peu de rÃ©utilisation (pas de modÃ¨les communs, beaucoup de transformations codÃ©es en dur).
ğŸ‘‰ RÃ©sultat : pipeline difficile Ã  comprendre, coÃ»ts Ã©levÃ©s de maintenance si une rÃ¨gle mÃ©tier change.

IntÃ©rÃªts Ã  payer : chaque modification demande beaucoup dâ€™efforts car tout est dispersÃ©.

4. Scripts Shell Unix

Exemple de dette : scripts shell qui manipulent des fichiers plats sans gestion dâ€™erreurs robuste (pas de log centralisÃ©, pas de gestion des retours dâ€™erreur).
ğŸ‘‰ RÃ©sultat : quand un fichier est absent ou corrompu, tout le traitement Ã©choue et il faut dÃ©bugger manuellement.

IntÃ©rÃªts Ã  payer : perte de temps des Ã©quipes dâ€™exploitation, manque dâ€™industrialisation.

5. Documentation et standardisation

Exemple de dette : absence de documentation des jobs, des rÃ¨gles mÃ©tier ou des dÃ©pendances entre tables.
ğŸ‘‰ RÃ©sultat : seules certaines personnes "historiques" comprennent le systÃ¨me.

IntÃ©rÃªts Ã  payer : risque Ã©levÃ© lors du turnover, allongement du temps dâ€™analyse pour toute Ã©volution.

ğŸš¨ ConsÃ©quences typiques

RigiditÃ© : chaque Ã©volution prend plus de temps que prÃ©vu.

FragilitÃ© : plus de risques dâ€™incidents en production.

Performance dÃ©gradÃ©e : traitements trop longs, surtout avec de grosses volumÃ©tries.

DifficultÃ©s de migration : dette accumulÃ©e qui rend le passage Ã  de nouvelles techno (ex. Snowflake, Airflow, dbt) beaucoup plus coÃ»teux.

âœ… Exemple concret de scÃ©nario

Un job DataStage charge une table Teradata via un script BTEQ ordonnancÃ© par Control-M.

Pour livrer vite, le dÃ©veloppeur a codÃ© une jointure complexe en SQL sans index, et ajoutÃ© un script shell pour renommer les fichiers.

Tout marcheâ€¦ mais au fil du temps, les volumes explosent â†’ le traitement prend 6h au lieu de 1h.

Quand on migre vers Snowflake, on doit rÃ©Ã©crire entiÃ¨rement le pipeline (DataStage â†’ dbt, BTEQ â†’ SnowSQL).
ğŸ‘‰ Ce quâ€™on avait "gagnÃ©" au dÃ©but en allant vite se paye trÃ¨s cher Ã  long terme.
